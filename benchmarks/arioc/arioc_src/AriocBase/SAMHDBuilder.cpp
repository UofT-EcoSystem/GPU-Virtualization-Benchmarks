/*
  SAMHDBuilder.cpp

    Copyright (c) 2015-2019 Johns Hopkins University.  All rights reserved.

    This file is part of the Arioc software distribution.  It is subject to the license terms
    in the LICENSE.txt file found in the top-level directory of the Arioc software distribution.
    The contents of this file, in whole or in part, may only be copied, modified, propagated, or
    redistributed in accordance with the license terms contained in LICENSE.txt.
*/
#include "stdafx.h"

#pragma region static variable definitions
const char* const SAMHDBuilder::m_samVersion = CONFIG_SAM_VERSION;

const char* const SAMHDBuilder::m_samAttributeOrder[AO1][AO2] =
                    { { "@HD", "VN", "SO", "GO", NULL },
                      { "@SQ", "SN", "LN", "AS", "M5", "SP", "UR", "rm", NULL },
                      { "@RG", "ID", "CN", "DS", "DT", "FO", "KS", "LB", "PG", "PI", "PL", "PU", "SM", NULL },
                      { "@PG", "ID", "fn", "PN", "CL", "PP", "DS", "VN", "dt", NULL },
                      { "@CO", NULL }
                    };

#pragma endregion

#pragma region constructors and destructor
/// [private] constructor
SAMHDBuilder::SAMHDBuilder()
{
    // (do not use this constructor)
}

/// [public] constructor
SAMHDBuilder::SAMHDBuilder( RGManager* prgm ) : m_prgm(prgm), m_docSAM(true), m_suppressHD(false), m_suppressCfg(true)
{
    memset( m_cmdTail, 0, sizeof m_cmdTail );
    memset( m_appName, 0, sizeof m_appName );
    memset( m_appVersion, 0, sizeof m_appVersion );
    memset( this->BigBucketThreshold, 0, sizeof this->BigBucketThreshold );
}

/// [public] destructor
SAMHDBuilder::~SAMHDBuilder()
{
}
#pragma endregion

#pragma region private methods
/// [private] method verifyVN
void SAMHDBuilder::verifyVN( tinyxml2::XMLDocument* _pxd, char* _baseName )
{
    // verify the AriocE version (formatted as "<major>.<minor>")
    tinyxml2::XMLElement* pelPG = _pxd->RootElement()->FirstChildElement( "PG" );
    const char* sv = pelPG->Attribute( "VN" );
    char* pEnd;
    long lv = strtol( sv, &pEnd, 10 );
    bool vok = (lv >= MIN_ENCODER_VERSION_MAJOR);
    if( vok )
    {
        lv = strtol( pEnd+1, &pEnd, 10 );
        vok = (lv >= MIN_ENCODER_VERSION_MINOR);
    }

    if( !vok )
        throw new ApplicationException( __FILE__, __LINE__, "%s encoded with invalid AriocE v%s (v1.30 or later required)", _baseName, sv );
}

/// [private] method addPG
void SAMHDBuilder::addPG( AriocAppMainBase* pamb )
{
    using namespace tinyxml2;

    // copy the application name and version strings
    strcpy_s( m_appName, sizeof m_appName, pamb->AppName );
    strcpy_s( m_appVersion, sizeof m_appVersion, pamb->AppVersion );

    // in the file name, replace double-quotes with the corresponding XML escape
    const char* pFrom = pamb->ConfigFileName;
    char* pTo = m_cmdTail;
    while( *pFrom )
    {
        // if the character is not a double-quote ...
        if( *pFrom != '"' )
        {
            // copy one character
            *(pTo++) = *(pFrom++);
            continue;
        }

        /* at this point we need to replace a double-quote with an escape */

        strcpy_s( pTo, 7, "&quot;" );
        pTo += 6;
        pFrom++ ;
    }
    *pTo = 0;

    // get the current system date and time as an ISO8601-formatted string
    TOD tod;
    char dt[20];
    sprintf_s( dt, sizeof dt, "%4u-%02u-%02uT%02u:%02u:%02u", tod.yr, tod.mo, tod.da, tod.hr, tod.mi, tod.se );

    /* At this point the XML document contains two <PG> elements generated by the AriocE application:
        - the PG element for the spaced-seed (nongapped) lookup tables
        - the PG element for the seed-and-extend (gapped) lookup tables
    */
    XMLElement* elSAM = m_docSAM.FirstChildElement( "SAM" );
    XMLElement* elPGg = elSAM->LastChildElement( "PG" );

    /* Build a new PG element for the Arioc application.  Although the input sequence data is presumably
        encoded by AriocE, there is no PP tag because there are multiple @PG IDs for AriocE. */
    XMLElement* elPG = m_docSAM.NewElement( "PG" );
    elPG->SetAttribute( "ID", m_appName );
    elPG->SetAttribute( "PN", m_appName );
    elPG->SetAttribute( "VN", m_appVersion );
    elPG->SetAttribute( "CL", m_cmdTail );
    elPG->SetAttribute( "dt", dt );

    // add the new PG element to the XML document
    elSAM->InsertAfterChild( elPGg, elPG );

    // update the HD element
    XMLElement* elHD = elSAM->FirstChildElement( "HD" );
    elHD->SetAttribute( "VN", m_samVersion );
    elHD->SetAttribute( "SO", "unsorted" );
    elHD->SetAttribute( "GO", "query" );    // (see SAMBuilderPaired::WriteRowPc and related functions)
}

/// [private] method addRG
void SAMHDBuilder::addRG( InputFileGroup* pifgQ )
{
    using namespace tinyxml2;

    /* For each input file...
        - we copy one or more read-group XML elements to the XML document that describes the SAM headers
        - we save a lookup table of read-group IDs that correspond to the read-group ordinal embedded
           in each .A21 row
    */
    for( UINT32 i=0; i<pifgQ->InputFile.n; ++i )
    {
        for( UINT32 n=0; n<m_prgm->OfsRG.n; ++n )
        {
            // make a local copy of the nth read group XML
            XMLDocument docRG;
            docRG.Parse( m_prgm->RG.p+m_prgm->OfsRG.p[n] );
            XMLElement* pelRGn = docRG.RootElement();
            if( pelRGn )
            {
                // make a local copy of the nth read group ID
                const char* IDn = pelRGn->Attribute( "ID" );

                // look for an RG element with a matching ID attribute in the SAM header document
                bool found = false;
                XMLElement* pelRG = m_docSAM.RootElement()->FirstChildElement( "RG" );
                while( pelRG )
                {
                    // if a matching ID attribute is found, set a flag and fall out of the loop
                    if( 0 == strcmp( pelRG->Attribute( "ID" ), IDn ) )
                    {
                        found = true;
                        break;
                    }

                    pelRG = pelRG->NextSiblingElement( "RG" );
                }

                if( found )
                {
                    // ensure that the remaining attribute values match
                    if( !SameXmlAttributes( pelRG, pelRGn ) )
                        throw new ApplicationException( __FILE__, __LINE__, "inconsistent read group attributes for ID='%s'", IDn );
                }
                else
                {
                    // add the read group info to the SAM header document
                    XMLNode* nodRG = pelRGn->ShallowClone( &m_docSAM );
                    m_docSAM.RootElement()->InsertEndChild( nodRG );
                }
            }
        }
    }
}

#pragma warning ( push )
#pragma warning( disable:4996 )     // (don't nag us about strcpy and _splitpath being "unsafe")

/// [private] method appendSAMtags
void SAMHDBuilder::appendSAMtags( char*& p, tinyxml2::XMLElement* pel )
{
    using namespace tinyxml2;

    // find the attribute order for the specified element
    INT32 ia1 = 0;
    for( ; ia1<AO1; ++ia1 )
    {
        if( 0 == strcmp( pel->Name(), m_samAttributeOrder[ia1][0]+1 ) )
            break;
    }

    // for elements not found in the attribute-order list, just append the attributes in the order they appear
    if( ia1 == AO1 )
    {
        const XMLAttribute* attr = pel->FirstAttribute();
        while( attr != NULL )
        {
            // build a name-value pair
            *(p++) = '\t';                  // separate SAM tags with a tab character
            strcpy( p, attr->Name() );      // tag name
            p += strlen( attr->Name() );
            *(p++) = ':';                   // separate tag name and value with a colon
                                            // (there's no type specifier here; the SAM spec is silent regarding whether it should appear for user-defined tags)
            strcpy( p, attr->Value() );     // tag value
            p += strlen( attr->Value() );
            attr = attr->Next();            // iterate
        }

        return;
    }

    // traverse the list of possible attributes for the SAM header row
    for( INT32 ia2=1; ia2<AO2; ++ia2 )
    {
        const char* attrName = m_samAttributeOrder[ia1][ia2];
        if( attrName == NULL )
            break;

        // get the attribute value (if any)
        const char* pValue = pel->Attribute( attrName );
        if( pValue )
        {
            // build a name-value pair
            *(p++) = '\t';                  // separate SAM tags with a tab character

            strcpy( p, attrName );          // tag name
            p += strlen( attrName );
            *(p++) = ':';                   // separate tag name and value with a colon
                                            // (there's no type specifier here; the SAM spec is silent regarding whether it should appear for user-defined tags)
            strcpy( p, pValue );            // tag value
            p += strlen( pValue );
        }
    }
}

/// [private] method buildSAMheader
void SAMHDBuilder::buildSAMheader()
{
    using namespace tinyxml2;

    // allocate a big buffer to contain the SAM header; we will adjust the buffer size later
    m_SAMheader.Realloc( HEADER_BUFFER_SIZE, false );
    char* p = m_SAMheader.p;

    /* Traverse the XML document to build the SAM header:
        - elements (HD, SQ, etc.) become SAM record-type codes
        - attributes (VN, SN, etc.) become SAM tag/value pairs
    */
    XMLElement* elSAM = m_docSAM.FirstChildElement( "SAM" );
    XMLElement* el = elSAM->FirstChildElement();
    while( el != NULL )
    {
        // SAM record type
        *(p++) = '@';
        strcpy( p, el->Name() );
        p += strlen( el->Name() );

        // SAM tags
        appendSAMtags( p, el );

        // terminate each line with a UNIX-style newline
        *(p++) = '\n';

        // iterate
        el = el->NextSiblingElement();
    }

    // adjust the buffer size
    m_SAMheader.Realloc( p-m_SAMheader.p, false );
}

/// [private] method getReferenceConfigFileSpec
void SAMHDBuilder::getReferenceConfigFileSpec( char* baseName, char* fileSpec, const char* pathCfg )
{
    // get the config filename from the rightmost component of the specified path
    strcpy_s( fileSpec, FILENAME_MAX, pathCfg );

    // build the file specification for the .cfg file
    RaiiDirectory::ChopTrailingPathSeparator( fileSpec );   // remove any trailing separator
    char* p = fileSpec + strlen(fileSpec) - 1;              // point to the rightmost character in the path string

    // iterate backwards through the path until either a separator or the start of the string is encountered
    while( (p >= fileSpec) && (*p != '\\') && (*p != '/') )
        p-- ;
    p++ ;       // point to the first character of the rightmost component of the path (i.e., the base name)
    strcpy_s( baseName, BASENAME_MAX, p );                  // return a copy of the base name    
    
    RaiiDirectory::AppendTrailingPathSeparator( fileSpec ); // append a separator
    strcat_s( fileSpec, FILENAME_MAX, baseName );           // append the base name
    strcat_s( fileSpec, FILENAME_MAX, ".cfg" );             // append the file extension
}
#pragma warning ( pop )
#pragma endregion

#pragma region public methods
/// [public] method Init
void SAMHDBuilder::Init( const char* pathCfgN, const char* pathCfgG, InputFileGroup* pifgQ, AriocAppMainBase* pamb )
{
    using namespace tinyxml2;

    XMLDocument* pdoc = NULL;

    try
    {
        // look for the Xparams that suppress SAM header output and SAM config file output
        INT32 i = pamb->Xparam.IndexOf( "SuppressSAMHeaders" );
        if( i >= 0 )
            m_suppressHD = (pamb->Xparam.Value(i) != 0 );
        i = pamb->Xparam.IndexOf( "SuppressSAMCfgFile" );
        if( i >= 0 )
            m_suppressCfg = (pamb->Xparam.Value(i) != 0 );

        // initialize an XML document using the configuration info for the nongapped lookup tables
        char fileSpec[FILENAME_MAX];
        char baseName[BASENAME_MAX];
        getReferenceConfigFileSpec( baseName, fileSpec, pathCfgN );     // spaced-seed (nongapped) lookup tables
        LoadXmlFile( &m_docSAM, fileSpec );
        verifyVN( &m_docSAM, baseName );

        // zap the fn attribute on the <SAM> element
        m_docSAM.RootElement()->DeleteAttribute( "fn" );

        // load configuration info for the gapped lookup tables
        getReferenceConfigFileSpec( baseName, fileSpec, pathCfgG );     // seed-and-extend (gapped) lookup tables
        XMLDocument* pdoc = new tinyxml2::XMLDocument;
        LoadXmlFile( pdoc, fileSpec );
        verifyVN( pdoc, baseName );

        // copy the PG info into this SAMHDBuilder's XML document
        XMLElement* pelPG = pdoc->RootElement()->FirstChildElement( "PG" );
        XMLNode* nodPG = pelPG->ShallowClone( &m_docSAM );
        m_docSAM.RootElement()->InsertEndChild( nodPG );

        // save the bucket-size threshold value used by the encoder for the seed-and-extend J lookup table
        const char* bbt = pelPG->Attribute( "mJ" );
        if( bbt )
            strcpy_s( this->BigBucketThreshold, sizeof this->BigBucketThreshold, bbt );

        delete pdoc;
        pdoc = NULL;

        // load configuration info for each of the encoded Q-sequence files
        for( UINT32 n=0; n<pifgQ->InputFile.n; ++n )
        {
            // replace "$a21.sbf" with ".cfg" in the A21 file specification
            strcpy_s( fileSpec, sizeof fileSpec, pifgQ->InputFile.p[n].Filespec );
            strcpy_s( fileSpec+strlen(fileSpec)-8, 5, ".cfg" );

            // load the XML document
            pdoc = new tinyxml2::XMLDocument;
            LoadXmlFile( pdoc, fileSpec );

            // copy the PG info into this SAMHDBuilder's XML document
            pelPG = pdoc->RootElement()->FirstChildElement( "PG" );
            nodPG = pelPG->ShallowClone( &m_docSAM );
            XMLElement* pelPGnew = reinterpret_cast<XMLElement*>(m_docSAM.RootElement()->InsertEndChild( nodPG ));

            delete pdoc;
            pdoc = NULL;

            /* The PGID tag must be unique within a SAM file, so we append a uniquifier as follows:
                - paired-end reads: <srcId>.<subId>p<mateId>
                - unpaired reads:   <srcId>.<subId>u<fileId>
            */
            char uniqueOrdinal[8];
            if( pifgQ->InputFile.p[n].IsPaired )
                sprintf_s( uniqueOrdinal, sizeof uniqueOrdinal, "p%u", pifgQ->InputFile.p[n].MateId+1 );
            else
                sprintf_s( uniqueOrdinal, sizeof uniqueOrdinal, "u%u", n );

            // append uniquifier to the PGID tag value
            char newPGID[FILENAME_MAX];
            sprintf_s( newPGID, sizeof newPGID,
                        "%s (%05d.%03u%s)",
                        pelPGnew->Attribute("ID"),
                        pifgQ->InputFile.p[n].SrcId, pifgQ->InputFile.p[n].SubId, uniqueOrdinal );
            pelPGnew->SetAttribute( "ID", newPGID );
        }

        // append a PG element for this application
        addPG( pamb );

#if TODO_CHOP_WHEN_DEBUGGED
        XMLPrinter lpt;
        m_docSAM.Print( &lpt );
        CDPrint( cdpCD0, "%s", __FUNCTION__ );
        OutputDebugString( lpt.CStr() );
#endif

        // append read group (RG) info
        addRG( pifgQ );

#if TODO_CHOP_WHEN_DEBUGGED
        XMLPrinter lpt;
        m_docSAM.Print( &lpt );
        CDPrint( cdpCD0, "%s", __FUNCTION__ );
        OutputDebugString( lpt.CStr() );
#endif

        // save the SAM-formatted header
        buildSAMheader();

#if TODO_CHOP_WHEN_DEBUGGED
        CDPrint( cdpCD0, __FUNCTION__ );
        OutputDebugString( m_SAMheader.p );
#endif
    }
    catch( ... )
    {
        if( pdoc )
            delete pdoc;
        throw;
    }
}

/// [public] method WriteHeader
void SAMHDBuilder::WriteHeader( RaiiFile& fileSAM )
{
    if( !m_suppressCfg )
    {
        // write SAM.cfg in the same directory as the first SAM file
        char cfgFileSpec[FILENAME_MAX] = { 0 };
        char driveLetter[_MAX_DRIVE] = { 0 };

#pragma warning ( push )
#pragma warning ( disable : 4996 )		// don't nag us about _splitpath and memcpy being "unsafe"
         // extract the drive letter (if any) and directory (with a trailing separator)
        _splitpath( fileSAM.FileSpec.p, driveLetter, cfgFileSpec, NULL, NULL );
        if( *driveLetter )
        {
            // slide the directory name over to make room for the drive letter
            size_t cch = strlen( driveLetter );
            memcpy( cfgFileSpec+cch, cfgFileSpec, strlen(cfgFileSpec)+1 );

            // insert the drive letter
            memcpy( cfgFileSpec, driveLetter, cch );
        }
#pragma warning ( pop )

        strcat_s( cfgFileSpec, FILENAME_MAX, "SAM.cfg" );                   // append the filename
        SaveXmlFile( cfgFileSpec, &m_docSAM );

        // set the flag so that we don't write the file more than once
        m_suppressCfg = true;
    }

    // write SAM header rows
    if( !m_suppressHD )
        fileSAM.Write( m_SAMheader.p, m_SAMheader.cb );
}
#pragma endregion
